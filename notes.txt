
.>!!protect each mutex create/join/mtx_init/mtx_destroy ... triple check

..> in cleanup upon failure still needs to clean everything? or just stick with error


if (pthread_mutex_lock(&mutex) != 0)
    return (error_exit("Mutex lock failed", symposium));


add ft_usleep
usleep in main loop?
usleep has a limit - so limit input for time_to_eat/sleep

improve logic .. currently who takes the next fork? where is the cutoff when philos NEED to die??
do thinking only when uneven number of philos?


.>protect for ulimit -v  (segfault??) -> return to main
